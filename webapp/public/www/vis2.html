<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">
    <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        #container {
            position: absolute;
            width: 80%;
            height: 80%;
        }
        .navbar{
            border-bottom: 0.5px solid #999;
            border-top: 2px solid orange;
        }
        #stop{
            margin-left:10px;
            font-size: 8pt;
            background: #f44556;
            border:none; 
           
        }
        #stop:hover{
            background-color: #f44336;
            color: white;
        }
        .reset{
            margin-left:10px;
            padding:0.5px 11px 1px 0.5px;
            font-size: 9pt !important;
            background-color:#008Cf4;
            border:none; 
            color:#000 !important;
            text-decoration: none;
        }
        .reset:hover{
            background-color: #008CBA;
            color: white !important;
            text-decoration: none;
        }
        .title{
            float:left;
        }
        #sidebar {
                position: fixed;
                bottom: 0;
                background: #FFF;

                padding-left:5%;

                min-height: 10%;
                min-width: 80%;
        }
        #legend {
                position: fixed;
                top: 0;
                left:0;
                margin-top:100px;
                background: #FFF;
                text-align: center;
                padding-top:2px; 
                padding-left: 1.2%;
                border: solid 1px #ccc;
                min-height: 10%;
                min-width: 5%;
                font-size: 7pt; 
        }
        #right-side-bar{
                position: fixed;
                top: 0;
                right:0;
                margin-top:65px;
                margin-right:10px;
                background: #FFF;
                text-align: center;
                padding-top:2px; 
                padding-left: 1.2%;
                
                min-height: 10%;
                min-width: 5%;
                font-size: 1rem; 
        }
    /*charts*/
    .chart {
        display: inline-block;
        height: 50px;
        margin-bottom: 10px;

    }

    .reset {
        padding-left: 1em;
        font-size: smaller;
        color: #ccc;
    }

    .background.bar {
        fill: #ccc;
        
    }

    .foreground.bar {
        fill: steelblue;
    }

    .brush-handle {
        fill: #eee;
        stroke: #666;
    }

    #hour-chart {
        width: 260px;
    }

    #delay-chart {
        width: 230px;
    }

    #distance-chart {
        width: 430px;
    }

    #date-chart {
        width: 920px;
    }

    #flight-list {
        min-height: 1024px;
    }

    #flight-list .date,
    #flight-list .day {
        margin-bottom: .4em;
    }

    #flight-list .flight {
        line-height: 1.5em;
        background: #eee;
        width: 925px;
        margin-bottom: 1px;
    }

    #flight-list .time {
        color: #999;
    }

    #flight-list .flight div {
        display: inline-block;
    }

    #flight-list div.time {
        width: 100px;
        text-align: left;
    }

    #flight-list div.origin {
        width: 50px;
        text-align: right;
        padding-right: 15px;
    }

    #flight-list div.destination {
        width: 100px;
        text-align: left;
        padding-left: 15px;
    }

    #flight-list div.distance {
        width: 100px;
        text-align: left;
    }

    #flight-list div.delay {
        width: 120px;
        padding-right: 0px;
        text-align: right;
    }

    #flight-list .early {
        color: green;
    }

    aside {
        position: absolute;
        left: 740px;
        font-size: smaller;
        width: 220px;
    }
    .list-group{
        text-align: left;
    }
    </style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.17.1/axios.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.noverlap.min.js"></script>



<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.js" charset="utf-8"></script>-->
<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dc/1.7.5/dc.js"></script>-->
<!--<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js' defer></script>-->
<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.12/crossfilter.js"></script>-->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/crossfilter2/1.4.3/crossfilter.min.js' defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reductio/0.6.3/reductio.min.js"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/dc/2.1.9/dc.min.js"></script>-->
<script src='https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.23.1/babel.min.js' defer></script>

<!--<script src='../js/vis2.js' defer></script>-->

</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01"
            aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
            <a class="navbar-brand" href="#"><img src="..\image\logo.png" height="30" width="100"></a>
            <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="index.html">Cluster of Tags</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="vis2.html">Link<span class="sr-only">(current)</span></a>
                </li>
            </ul>

        </div>
    </nav>
    <br/>
    <div id="container"></div>
    <div id="sidebar">
        <div id='charts'>
            <div id='date-chart' class='chart'>
                <div class='title'><b>Date</b></div>
                <button id="stop">Stop animation</button>
                <!--<svg width="960" height="600"></svg>-->

            </div>
        </div>
    </div>
    <div id="legend">
        <div class='title'><b>Legend</b></div>
    </div>
    <div id="right-side-bar">
        <div class="list-group">
            <a href="#" class="list-group-item list-group-item-action" > <b>Ranking </b></a>
            <a href="#" class="list-group-item list-group-item-action" style="background-color:#fff8e2" > 1. Dapibus ac facilisis in</a>
            <a href="#" class="list-group-item list-group-item-action" style="background-color:#edeeef"> 2. Cras sit amet nibh libero</a>
            <a href="#" class="list-group-item list-group-item-action" style="background-color:#f9ebe1">3. Porta ac consectetur ac</a>
            <a href="#" class="list-group-item list-group-item-action" style="background-color:#fff"> 4. Vestibulum at eros</a>
            <a href="#" class="list-group-item list-group-item-action" style="background-color:#fff"> 5. Vestibulum at eros</a>
        </div>
    </div>
    <script>
        let query = function (statements, transform) {

            var config = {
                method: 'post',
                headers: { 'Content-type': 'application/json', 'Accept': 'application/json; charset=utf-8', 'X-stream': true },
                data: {
                    "statements": statements
                }
            }
            if (typeof transform !== 'undefined') {
                config.transformResponse = transform
            }
            // returns promise
            return axios('http://35.198.202.139:7474/db/data/transaction/commit', config)
        }

        let vis = function (data) {

            let svg = d3.select("svg"),
                width = +svg.attr("width"),
                height = +svg.attr("height");

            let color = d3.scaleOrdinal(d3.schemeCategory20);

            let simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(function (d) { return d.UserId; }))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(width / 2, height / 2));

            let link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("stroke-width", function (d) { return Math.sqrt(d.value); });

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        let getStatementByTag = function (tag) {
            return [
                {
                    "statement": "MATCH (t:Tag {TagId: $tag})--(p:Posts) " +
                    "WITH p MATCH (from:User)-[r:Comment]->(p)<-[:CREATES]-(to:User) " +
                    "RETURN {from:from,rel:r,to:to}",
                    "parameters": {
                        "tag": tag
                    },
                    "resultDataContents": ["row"],
                },
                {
                    "statement": "MATCH (t:Tag {TagId: $tag})--(p:Posts) " +
                    "WITH p MATCH (from:User)-[r:LAST_EDITED]->(p)<-[:CREATES]-(to:User)" +
                    "RETURN {from:from, rel:r, to:to}",
                    "parameters": {
                        "tag": tag
                    },
                    "resultDataContents": ["row"]
                },
                {
                    "statement": "MATCH (t:Tag {TagId: $tag})--(p:Posts) " +
                    "WITH p MATCH (from:User)-[:CREATES]-(a:Posts)-[r:ANSWERS]->(p)-[:CREATES]-(to:User)" +
                    "RETURN {from:from, rel:{CreationDate:a.CreationDate}, to:to}",
                    "parameters": {
                        "tag": tag
                    },
                    "resultDataContents": ["row"]
                },
                {
                    "statement": "MATCH (t:Tag {TagId: $tag})--(p:Posts) " +
                    "WITH p MATCH (from:User)-[:CREATES]-(a:Posts)<-[r:PARENT_OF]-(p)-[:CREATES]-(to:User)" +
                    "RETURN {from:from, rel:{CreationDate:a.CreationDate}, to:to}",
                    "parameters": {
                        "tag": tag
                    },
                    "resultDataContents": ["row"]
                }
            ]
        }
        let sigmavis = function (data) {
            //JSNETWORKX GRAPH
            var G = new jsnx.Graph();
            data.nodes.forEach((d, i, a) => {
                G.addNode(d.UserId)
            });

            data.links.forEach((d, i) => {
                G.addEdge(d.source, d.target)
            });

            let results = new jsnx.genBetweennessCentrality(G);

            sigma.settings.nodesPowRatio = 0.5;
            sigma.settings.autoRescale = false;

            let s = new sigma({
                renderer: {
                    container: document.getElementById('container'),
                    type: 'canvas',
                    settings: {
                        defaultNodeColor: '#ec5148',
                        edgeColor: 'default',
                        defaultEdgeColor: '#ccc',
                        animationsTime: 5000,
                        //drawLabels: false,
                        //batchEdgesDrawing: true,
                        hideEdgesOnMove: true,
                        sideMargin: 1,
                        labelThreshold: 8,
                    }
                },
            });

            data.nodes.forEach((d, i, a) => {
                s.graph.addNode({
                    id: d.UserId,
                    label: d.DisplayName,
                    x: Math.random() * 1000,
                    y: Math.random() * 1000,
                    size: 1,
                })
            })

            data.links.forEach((d, i) => {
                s.graph.addEdge({
                    id: i,
                    source: d.source,
                    target: d.target
                })
            })

            results.then(function (a) {
                let obj = a._stringValues
                let minVal = Math.sqrt(Math.min.apply(null, Object.values(obj)))
                let maxVal = Math.sqrt(Math.max.apply(null, Object.values(obj)))
                var colorSeq = d3.scaleSequential()
                    .domain([minVal, maxVal])
                    .interpolator(d3.interpolateRgb.gamma(3.0)("red", "blue"))
                Object.keys(obj).forEach(function (k) {
                    //                console.log(k, obj[k])
                    s.graph.nodes(k).color = colorSeq(Math.sqrt(obj[k]))
                    //s.graph.nodes(k).color = colorSeq(obj[k])
                });
                s.refresh();
            });

            //PAUSE ANIMATION
            isStop = false
            button = document.getElementById('stop')
            button.onclick = () => {
                if (isStop) {
                    s.startForceAtlas2()
                    isStop = false
                } else {
                    s.stopForceAtlas2()
                    isStop = true
                }
            }

            //NODE SIZE BASED ON DEGREE
            nodeArr = s.graph.nodes().map(v => s.graph.degree(v.id))
            binner = d3.scaleQuantize().domain([Math.min.apply(null, nodeArr), Math.max.apply(null, nodeArr)]).range([2, 4, 8, 16, 32])
            s.graph.nodes().forEach(v => v.size = binner(s.graph.degree(v.id)))
            // Finally, let's ask our sigma instance to refresh:
            s.refresh();
            s.configForceAtlas2({

                //            worker: true,
                //            autoStop: false,
                //            background: false,
                //            adjustSizes: true,
                gravity: 20
            });
            s.startForceAtlas2()


        }

        let barVolumeChart = function (dim, start, end, renderGraph, graph) {
            let dates = dim.group(d3.timeDay)
            const formatNumber = d3.format(',d');
            const charts = [
                barChart()
                    .dimension(dim)
                    .group(dates)
                    .round(d3.timeDay.round)
                    .x(d3.scaleTime()
                        .domain([start, end])
                        .rangeRound([0, 10 * 90]))
                    .filter([start, end])
            ]
            const chart = d3.selectAll('.chart')
                .data(charts);

            function render(method) {
                d3.select(this).call(method);
            }

            // Whenever the brush moves, re-rendering everything.
            function renderAll() {
                chart.each(render);
                // what's this
                //            d3.select('#active').text(formatNumber(all.value()));

                renderGraph()
            }
            renderAll();
            function barChart() {
                if (!barChart.id) barChart.id = 0;

                let margin = { top: 10, right: 13, bottom: 20, left: 10 };
                let x;
                let y = d3.scaleLinear().range([100, 0]);
                const id = barChart.id++;
                const axis = d3.axisBottom();
                const brush = d3.brushX();
                let brushDirty;
                let dimension;
                let group;
                let round;
                let gBrush;

                function chart(div) {
                    const width = x.range()[1];
                    const height = y.range()[0];

                    brush.extent([[0, 0], [width, height]]);

                    y.domain([0, group.top(1)[0].value]);

                    div.each(function () {
                        const div = d3.select(this);
                        let g = div.select('g');

                        // Create the skeletal chart.
                        if (g.empty()) {
                            div.select('.title').append('a')
                                .attr('href', `javascript:reset(${id})`)
                                .attr('class', 'reset')
                                .text('reset')
                                .style('display', 'none');

                            g = div.append('svg')
                                .attr('width', width + margin.left + margin.right)
                                .attr('height', height + margin.top + margin.bottom)
                                .append('g')
                                .attr('transform', `translate(${margin.left},${margin.top})`);

                            g.append('clipPath')
                                .attr('id', `clip-${id}`)
                                .append('rect')
                                .attr('width', width)
                                .attr('height', height);

                            g.selectAll('.bar')
                                .data(['background', 'foreground'])
                                .enter().append('path')
                                .attr('class', d => `${d} bar`)
                                .datum(group.all());

                            g.selectAll('.foreground.bar')
                                .attr('clip-path', `url(#clip-${id})`);

                            g.append('g')
                                .attr('class', 'axis')
                                .attr('transform', `translate(0,${height})`)
                                .call(axis);

                            // Initialize the brush component with pretty resize handles.
                            gBrush = g.append('g')
                                .attr('class', 'brush')
                                .call(brush);

                            gBrush.selectAll('.handle--custom')
                                .data([{ type: 'w' }, { type: 'e' }])
                                .enter().append('path')
                                .attr('class', 'brush-handle')
                                .attr('cursor', 'ew-resize')
                                .attr('d', resizePath)
                                .style('display', 'none');
                        }

                        // Only redraw the brush if set externally.
                        if (brushDirty !== false) {
                            const filterVal = brushDirty;
                            brushDirty = false;

                            div.select('.title a').style('display', d3.brushSelection(div) ? null : 'none');

                            if (!filterVal) {
                                g.call(brush);

                                g.selectAll(`#clip-${id} rect`)
                                    .attr('x', 0)
                                    .attr('width', width);

                                g.selectAll('.brush-handle').style('display', 'none');
                                renderAll();
                            } else {
                                const range = filterVal.map(x);
                                brush.move(gBrush, range);
                            }
                        }

                        g.selectAll('.bar').attr('d', barPath);
                    });

                    function barPath(groups) {
                        const path = [];
                        let i = -1;
                        const n = groups.length;
                        let d;
                        while (++i < n) {
                            d = groups[i];
                            path.push('M', x(d.key), ',', height, 'V', y(d.value), 'h9V', height);
                        }
                        return path.join('');
                    }

                    function resizePath(d) {
                        const e = +(d.type === 'e');
                        const x = e ? 1 : -1;
                        const y = height / 3;
                        return `M${0.5 * x},${y}A6,6 0 0 ${e} ${6.5 * x},${y + 6}V${2 * y - 6}A6,6 0 0 ${e} ${0.5 * x},${2 * y}ZM${2.5 * x},${y + 8}V${2 * y - 8}M${4.5 * x},${y + 8}V${2 * y - 8}`;
                    }
                }

                brush.on('start.chart', function () {
                    const div = d3.select(this.parentNode.parentNode.parentNode);
                    div.select('.title a').style('display', null);
                });

                brush.on('brush.chart', function () {
                    const g = d3.select(this.parentNode);
                    const brushRange = d3.event.selection || d3.brushSelection(this); // attempt to read brush range
                    const xRange = x && x.range(); // attempt to read range from x scale
                    let activeRange = brushRange || xRange; // default to x range if no brush range available

                    const hasRange = activeRange &&
                        activeRange.length === 2 &&
                        !isNaN(activeRange[0]) &&
                        !isNaN(activeRange[1]);

                    if (!hasRange) return; // quit early if we don't have a valid range

                    // calculate current brush extents using x scale
                    let extents = activeRange.map(x.invert);

                    // if rounding fn supplied, then snap to rounded extents
                    // and move brush rect to reflect rounded range bounds if it was set by user interaction
                    if (round) {
                        extents = extents.map(round);
                        activeRange = extents.map(x);

                        if (
                            d3.event.sourceEvent &&
                            d3.event.sourceEvent.type === 'mousemove'
                        ) {
                            d3.select(this).call(brush.move, activeRange);
                        }
                    }

                    // move brush handles to start and end of range
                    g.selectAll('.brush-handle')
                        .style('display', null)
                        .attr('transform', (d, i) => `translate(${activeRange[i]}, 0)`);

                    // resize sliding window to reflect updated range
                    g.select(`#clip-${id} rect`)
                        .attr('x', activeRange[0])
                        .attr('width', activeRange[1] - activeRange[0]);

                    // filter the active dimension to the range extents
                    dimension.filterRange(extents);

                    // re-render the other charts accordingly
                    renderAll();
                });

                brush.on('end.chart', function () {
                    // reset corresponding filter if the brush selection was cleared
                    // (e.g. user "clicked off" the active range)
                    if (!d3.brushSelection(this)) {
                        reset(id);
                    }
                });

                chart.margin = function (_) {
                    if (!arguments.length) return margin;
                    margin = _;
                    return chart;
                };

                chart.x = function (_) {
                    if (!arguments.length) return x;
                    x = _;
                    axis.scale(x);
                    return chart;
                };

                chart.y = function (_) {
                    if (!arguments.length) return y;
                    y = _;
                    return chart;
                };

                chart.dimension = function (_) {
                    if (!arguments.length) return dimension;
                    dimension = _;
                    return chart;
                };

                chart.filter = _ => {
                    if (!_) dimension.filterAll();
                    brushDirty = _;
                    return chart;
                };

                chart.group = function (_) {
                    if (!arguments.length) return group;
                    group = _;
                    return chart;
                };

                chart.round = function (_) {
                    if (!arguments.length) return round;
                    round = _;
                    return chart;
                };

                chart.gBrush = () => gBrush;

                return chart;
            }
        }
        let nodeRadius = 10,
            inertia = 0.8,
            springForce = 0.01,
            springLength = 50,
            maxDisplacement = 15,
            gravity = 1.5;
        sigma.classes.graph.addMethod('computePhysics', function () {
            var i,
                j,
                l = this.nodesArray.length,
                s,
                t,
                dX,
                dY,
                d,
                v;
            for (i = 0; i < l; i++) {
                s = this.nodesArray[i];
                s.dX *= inertia;
                s.dY *= inertia;
                s.dY += gravity;
                for (j = i + 1; j < l; j++) {
                    t = this.nodesArray[j];
                    dX = s.x - t.x;
                    dY = s.y - t.y;
                    d = Math.sqrt(dX * dX + dY * dY);
                    v = ((d < 2 * nodeRadius) ? (2 * nodeRadius - d) / d / 2 : 0) -
                        ((this.allNeighborsIndex[s.id] || {})[t.id] ? springForce * (d - springLength) : 0);
                    t.dX -= v * dX;
                    t.dY -= v * dY;
                    s.dX += v * dX;
                    s.dY += v * dY;
                }
            }
            for (i = 0; i < l; i++) {
                s = this.nodesArray[i];
                s.dX = Math.max(Math.min(s.dX, maxDisplacement), -maxDisplacement);
                s.dY = Math.max(Math.min(s.dY, maxDisplacement), -maxDisplacement);
                s.x += s.dX;
                s.y += s.dY;
                // Collision with the ground:
                s.y = Math.min(-nodeRadius, s.y);
            }
        });
        let anotherSigmaVis = function (data) {
            // Create cross filter on link edge
            let edgeCrossFilter = crossfilter(data.links)

            // Create nodes list using sigma, dummy graph for referencing nodes
            let s = new sigma()
            let s2 = new sigma({
                renderer: {
                    container: document.getElementById('container'),
                    type: 'webgl',
                    settings: {
                        defaultNodeColor: '#ec5148',
                        edgeColor: 'default',
                        defaultEdgeColor: '#ccc',
                        animationsTime: 5000,
                        //drawLabels: false,
                        //batchEdgesDrawing: true,
                        hideEdgesOnMove: true,
                        sideMargin: 1,
                        labelThreshold: 8,
                    }
                },
            });
            data.nodes.forEach((d, i, a) => {
                s.graph.addNode({
                    id: d.UserId,
                    label: d.DisplayName,
                    x: Math.random() * 1000,
                    y: Math.random() * 1000,
                    size: 1
                })
            })

            // Create dimmension by time.
            let edgeByDate = edgeCrossFilter.dimension(function (d) {
                var t = new Date(1970, 0)
                t.setSeconds(d.time)
                return t
            })
            edgeByDate.filter([new Date(2016, 0), new Date(2017, 0)])
            barVolumeChart(edgeByDate, new Date(2016, 0), new Date(2017, 0), render, s2)
            //        render()

            // Create button click command
            //let button = document.getElementById('search')
            //        button.onclick = () => {
            //            console.log('clicked')
            //            let startDate = document.getElementById('start-date').value
            //            let endDate = document.getElementById('end-date').value
            //            edgeByDate.filter(null)
            //            edgeByDate.filter([new Date(startDate), new Date(endDate)])
            //            barVolumeChart(edgeByDate, new Date(startDate), new Date(endDate))
            //            render()
            //        }
            function render() {
                s2.graph.computePhysics();
                s2.graph.clear();
                let graphObjects = edgeByDate.top(Infinity)
                let filteredCF = crossfilter(edgeCrossFilter.allFiltered())
                let pairDim = filteredCF.dimension(d => [d.source, d.target])
                let pairList = pairDim.group().reduceCount().all()
                let sourceList = graphObjects.map(v => v.source).filter((v, i, arr) => i == arr.indexOf(v))
                let targetList = graphObjects.map(v => v.target).filter((v, i, arr) => i == arr.indexOf(v))
                let allList = sourceList.concat(targetList)
                let uniqueNodes = allList.filter((v, i, arr) => i == arr.indexOf(v))
                uniqueNodes.forEach(r => s2.graph.addNode({
                    id: r,
                    label: s.graph.nodes(r).label,
                    x: Math.random() * 1000,
                    y: Math.random() * 1000,
                    dX: 0,
                    dY: 0,
                    size: 1
                }))
                //            console.log(pairList.length)
                //            console.log(graphObjects.length)
                pairList.forEach((r, i) => {
                    s2.graph.addEdge({
                        id: i,
                        source: r.key[0],
                        target: r.key[1],
                        size: r.value * 10
                    })
                })
                s2.refresh();

                if (s2.isForceAtlas2Running() == true) {
                    s2.killForceAtlas2();
                }

                s2.configForceAtlas2({

                    //            worker: true,
                    //            autoStop: false,
                    //            background: false,
                    //            adjustSizes: true,
                    gravity: 20
                });
                s2.startForceAtlas2();
            }

        }
        let pipe = function (data) {
            let resultlists = data.results.map(o => o.data).reduce((a, v) => a.concat(v), [])
            let links = resultlists.filter(o => typeof (o.row[0].rel.CreationDate) !== 'undefined').map(function (o) {
                return {
                    "source": o.row[0].from.UserId,
                    "target": o.row[0].to.UserId,
                    "time": o.row[0].rel.CreationDate,
                    "key": o.row[0].from.UserId + ':' + o.row[0].to.UserId
                }
            })

            let nodesmap = {}
            for (let i = 0; i < resultlists.length; i++) {
                let row = resultlists[i].row[0]
                nodesmap[row.from.UserId] = row.from
                nodesmap[row.to.UserId] = row.to
            }
            let nodes = Object.keys(nodesmap).map(key => nodesmap[key])
            return {
                "nodes": nodes,
                "links": links
            }
        }
        let promise = query(getStatementByTag("neo4j"), [JSON.parse, pipe])
        promise.then((data) => anotherSigmaVis(data.data))
            .catch(e => console.log(e))
    </script>
</body>

</html>